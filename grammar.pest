//! Protocol Encoding DSL Grammar (PEST)
//!
//! Structure: transport (headers) -> messages -> structs -> base types
//! Supports: bits, padding, range values, length/count fields, compounds.

COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | COMMENT }

// --- Top-level ---
// Sections can be interleaved: type (abstract data model), message/struct (encoding), enum, transport, payload.
protocol = { SOI ~ (transport_section)? ~ (payload_section)? ~ (type_section | message_section | struct_section | enum_section)* ~ EOI }

transport_section  = { "transport" ~ "{" ~ transport_field* ~ "}" }
payload_section    = { "payload" ~ "{" ~ payload_field* ~ "}" }
type_section       = { "type" ~ ident ~ "{" ~ type_def_field* ~ "}" }
message_section    = { "message" ~ ident ~ "{" ~ message_field* ~ "}" }
struct_section     = { "struct" ~ ident ~ "{" ~ struct_field* ~ "}" }
enum_section       = { "enum" ~ ident ~ "{" ~ enum_variant* ~ "}" }
enum_variant       = { ident ~ "=" ~ literal ~ ";" }

// --- Abstract data model (ASN.1-like type definitions) ---
doc_tag = { "@doc" ~ string_literal }
type_def_field = { doc_tag? ~ ident ~ ":" ~ abstract_type_spec ~ type_optional? ~ ("[" ~ constraint ~ "]")? ~ quantum_spec? ~ ";" }
type_optional = { "?" }
abstract_type_spec = { abstract_seq_type | abstract_base_type | ident }
abstract_seq_type = { "sequence" ~ "of" ~ abstract_type_spec }
abstract_base_type = { "integer" | "boolean" | "octets" | "real" }

// Payload: messages that can follow transport; optional selector; optional repeated (list of records per block)
payload_field = { messages_list | selector_spec | repeated_spec }
messages_list = { "messages" ~ ":" ~ ident ~ ("," ~ ident)* ~ ";" }
selector_spec = { "selector" ~ ":" ~ ident ~ "->" ~ (selector_mapping ~ ",")* ~ selector_mapping ~ ";" }
selector_mapping = { literal ~ ":" ~ selector_msg_type }
selector_msg_type = { selector_list_type | ident }
selector_list_type = { "list" ~ "<" ~ ident ~ ">" }
repeated_spec = { "repeated" ~ ";" }

// --- Transport (frame/header envelope) ---
transport_field = {
    ident ~ ":" ~ transport_type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ quantum_spec? ~ ";"
}
transport_type_spec = {
    sized_int_type
    | base_type
    | padding_type
    | bitfield_type
    | magic_type
}
magic_type = { "magic" ~ "(" ~ literal_bytes ~ ")" }

// --- Message body fields ---
message_field = {
    doc_tag? ~ ident ~ ":" ~ type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ quantum_spec? ~ ("if" ~ ident ~ "==" ~ literal)? ~ ";"
}
struct_field = {
    ident ~ ":" ~ type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ quantum_spec? ~ ("if" ~ ident ~ "==" ~ literal)? ~ ";"
}

// --- Type specifications ---
// Sized int: integer stored in n bits, e.g. u16(14) or i16(10); use instead of bitfield(n) when value is an integer
type_spec = {
    sized_int_type
    | base_type
    | padding_type
    | bitfield_type
    | length_of_type
    | count_of_type
    | presence_bits_type
    | bitmap_type
    | list_type
    | rep_list_type
    | octets_fx_type
    | optional_type
    | array_type
    | struct_ref_type
}
octets_fx_type = { "octets_fx" }

// ASN.1-style bitmap: n bytes (1, 2, or 4); following optional fields use bits 0,1,2,...
presence_bits_type = { "presence_bits" ~ "(" ~ num ~ ")" }
// Bitmap: bitmap(total_bits, presence_per_block).
// total_bits = number of presence bits (optionals). presence_per_block = 0 => no FX (consecutive bits);
// presence_per_block = k > 0 => blocks of k presence bits then 1 FX bit (FX=0 on last block).
bitmap_size = { "(" ~ num ~ "," ~ num ~ ")" }
bitmap_type = { "bitmap" ~ bitmap_size ~ ("->" ~ "(" ~ bitmap_mapping_list ~ ")")? }
bitmap_mapping_list = { (bitmap_bit_mapping ~ ",")* ~ bitmap_bit_mapping }
bitmap_bit_mapping = { num ~ ":" ~ ident }

base_type = { "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "bool" | "float" | "double" }
sized_int_type = { int_base ~ "(" ~ num ~ ")" }
int_base = { "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" }

// padding(n) = n bytes; padding(n, bits) = n bits (zero on encode). Space after comma optional.
padding_bits_suffix = { "," ~ (" ")? ~ "bits" }
padding_type   = { "padding" ~ "(" ~ num ~ padding_bits_suffix? ~ ")" }
bitfield_type  = { "bitfield" ~ "(" ~ num ~ ")" }

length_of_type = { "length_of" ~ "(" ~ ident ~ ")" }
count_of_type  = { "count_of" ~ "(" ~ ident ~ ")" }

struct_ref_type = { ident }  // reference to a defined struct
array_type      = { type_spec_inner ~ "[" ~ array_len ~ "]" }
list_type       = { "list" ~ "<" ~ type_spec_inner ~ ">" }
rep_list_type   = { "rep_list" ~ "<" ~ type_spec_inner ~ ">" }
optional_type   = { "optional" ~ "<" ~ type_spec_inner ~ ">" }

type_spec_inner = {
    list_type
    | rep_list_type
    | sized_int_type
    | base_type
    | padding_type
    | bitfield_type
    | octets_fx_type
    | struct_ref_type
}

array_len = { ident | num }  // count field name or constant

// --- Constraints (validation) ---
// Range: one interval [min..max] or concatenation [min1..max1, min2..max2, ...]
constraint = { range_constraint | enum_constraint }
interval = { num ~ ".." ~ num }
range_constraint = { interval ~ ("," ~ interval)* }
enum_constraint  = { "(" ~ literal ~ ("," ~ literal)* ~ ")" }
// Quantum: resolution/unit per spec (e.g. "1/256 NM", "360/65536 Â°")
quantum_spec = { "quantum" ~ string_literal }

// --- Literals ---
literal = { num | "true" | "false" | hex_literal | string_literal }
literal_bytes = { string_literal | hex_literal }
num = @{ ("-")? ~ ("0" | ('1'..'9' ~ ('0'..'9')*)) }
hex_literal = @{ "0x" ~ ('0'..'9' | 'a'..'f' | 'A'..'F')+ }
string_literal = @{ "\"" ~ (!"\"" ~ ( "\\" ~ ANY | ANY ))* ~ "\"" }

ident_start = @{ 'a'..'z' | 'A'..'Z' | "_" }
ident_rest  = @{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" }
ident = @{ ident_start ~ ident_rest* }
