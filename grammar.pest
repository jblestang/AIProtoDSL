//! Protocol Encoding DSL Grammar (PEST)
//!
//! Structure: transport (headers) -> messages -> structs -> base types
//! Supports: bits, padding, reserved, range values, length/count fields, compounds.

COMMENT = _{ "//" ~ (!"\n" ~ ANY)* | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
WHITESPACE = _{ " " | "\t" | "\n" | "\r" | COMMENT }

// --- Top-level ---
// payload: which messages can follow transport and how to select message type from a transport field
protocol = { SOI ~ (transport_section)? ~ (payload_section)? ~ (message_section)* ~ (struct_section)* ~ EOI }

transport_section = { "transport" ~ "{" ~ transport_field* ~ "}" }
payload_section   = { "payload" ~ "{" ~ payload_field* ~ "}" }
message_section   = { "message" ~ ident ~ "{" ~ message_field* ~ "}" }
struct_section    = { "struct" ~ ident ~ "{" ~ struct_field* ~ "}" }

// Payload: messages that can follow transport; optional selector; optional repeated (list of records per block)
payload_field = { messages_list | selector_spec | repeated_spec }
messages_list = { "messages" ~ ":" ~ ident ~ ("," ~ ident)* ~ ";" }
selector_spec = { "selector" ~ ":" ~ ident ~ "->" ~ (selector_mapping ~ ",")* ~ selector_mapping ~ ";" }
selector_mapping = { literal ~ ":" ~ ident }
repeated_spec = { "repeated" ~ ";" }

// --- Transport (frame/header envelope) ---
transport_field = {
    ident ~ ":" ~ transport_type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ ";"
}
transport_type_spec = {
    sized_int_type
    | base_type
    | padding_type
    | reserved_type
    | bitfield_type
    | magic_type
}
magic_type = { "magic" ~ "(" ~ literal_bytes ~ ")" }

// --- Message body fields ---
message_field = {
    ident ~ ":" ~ type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ ("if" ~ ident ~ "==" ~ literal)? ~ ";"
}
struct_field = {
    ident ~ ":" ~ type_spec ~ ("=" ~ literal)? ~ ("[" ~ constraint ~ "]")? ~ ("if" ~ ident ~ "==" ~ literal)? ~ ";"
}

// --- Type specifications ---
// Sized int: integer stored in n bits, e.g. u16(14) or i16(10); use instead of bitfield(n) when value is an integer
type_spec = {
    sized_int_type
    | base_type
    | padding_type
    | reserved_type
    | bitfield_type
    | length_of_type
    | count_of_type
    | presence_bits_type
    | fspec_type
    | padding_bits_type
    | list_type
    | optional_type
    | array_type
    | struct_ref_type
}

// ASN.1-style bitmap: n bytes (1, 2, or 4); following optional fields use bits 0,1,2,...
presence_bits_type = { "presence_bits" ~ "(" ~ num ~ ")" }
// ASTERIX FSPEC: variable-length bytes until FX=0; 7 presence bits per byte; optional explicit bit->field mapping
fspec_type = { "fspec" ~ ("->" ~ "(" ~ fspec_mapping_list ~ ")")? }
fspec_mapping_list = { (fspec_bit_mapping ~ ",")* ~ fspec_bit_mapping }
fspec_bit_mapping = { num ~ ":" ~ ident }
// Spare/reserved bits (zero on encode)
padding_bits_type = { "padding_bits" ~ "(" ~ num ~ ")" }

base_type = { "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" | "bool" | "float" | "double" }
sized_int_type = { int_base ~ "(" ~ num ~ ")" }
int_base = { "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" }

padding_type   = { "padding" ~ "(" ~ num ~ ")" }
reserved_type  = { "reserved" ~ "(" ~ num ~ ")" }
bitfield_type  = { "bitfield" ~ "(" ~ num ~ ")" }

length_of_type = { "length_of" ~ "(" ~ ident ~ ")" }
count_of_type  = { "count_of" ~ "(" ~ ident ~ ")" }

struct_ref_type = { ident }  // reference to a defined struct
array_type      = { type_spec_inner ~ "[" ~ array_len ~ "]" }
list_type       = { "list" ~ "<" ~ type_spec_inner ~ ">" }
optional_type   = { "optional" ~ "<" ~ type_spec_inner ~ ">" }

type_spec_inner = {
    list_type
    | sized_int_type
    | base_type
    | padding_type
    | reserved_type
    | bitfield_type
    | padding_bits_type
    | struct_ref_type
}

array_len = { ident | num }  // count field name or constant

// --- Constraints (validation) ---
// Range: one interval [min..max] or concatenation [min1..max1, min2..max2, ...]
constraint = { range_constraint | enum_constraint }
interval = { num ~ ".." ~ num }
range_constraint = { interval ~ ("," ~ interval)* }
enum_constraint  = { "in" ~ "(" ~ literal ~ ("," ~ literal)* ~ ")" }

// --- Literals ---
literal = { num | "true" | "false" | hex_literal | string_literal }
literal_bytes = { string_literal | hex_literal }
num = @{ ("-")? ~ ("0" | ('1'..'9' ~ ('0'..'9')*)) }
hex_literal = @{ "0x" ~ ('0'..'9' | 'a'..'f' | 'A'..'F')+ }
string_literal = @{ "\"" ~ (!"\"" ~ ( "\\" ~ ANY | ANY ))* ~ "\"" }

ident_start = @{ 'a'..'z' | 'A'..'Z' | "_" }
ident_rest  = @{ 'a'..'z' | 'A'..'Z' | '0'..'9' | "_" }
ident = @{ ident_start ~ ident_rest* }
